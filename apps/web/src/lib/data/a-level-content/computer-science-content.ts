/**
 * A-Level Computer Science - Complete Learning Content  
 * Updated for 2025/2026 Academic Year
 * Covers: AQA 7517, Edexcel 9CS0, OCR H446, WJEC
 */

import { LessonContent } from '../eleven-plus-content/verbal-reasoning-content';

const aLevelComputerScienceContent: LessonContent[] = [
  {moduleNumber: 1, title: 'Programming Fundamentals', duration: '120 min', introduction: 'Variables, data types, operators, control structures', keyPoints: ['Variables and constants', 'Data types: int, float, string, bool', 'Operators: arithmetic, comparison, logical', 'Sequence, selection, iteration', 'Functions and procedures'], explanation: 'Foundation of all programming', examples: [
    {question: 'Write a function to find the factorial of a number', workingOut: 'PROBLEM: Calculate n! = n Ã— (n-1) Ã— ... Ã— 2 Ã— 1\n\nSOLUTION 1: Iterative\n\ndef factorial_iterative(n):\n    """Calculate factorial using iteration"""\n    if n < 0:\n        return "Error: negative number"\n    \n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n\n# Test\nprint(factorial_iterative(5))  # 120\n\nSTEPS:\n1. Check for negative (invalid)\n2. Initialize result = 1\n3. Loop from 1 to n\n4. Multiply result by each number\n5. Return result\n\nSOLUTION 2: Recursive\n\ndef factorial_recursive(n):\n    """Calculate factorial using recursion"""\n    if n < 0:\n        return "Error: negative number"\n    if n == 0 or n == 1:\n        return 1  # Base case\n    else:\n        return n * factorial_recursive(n - 1)  # Recursive case\n\n# Trace for n=5:\nfactorial(5) = 5 Ã— factorial(4)\n             = 5 Ã— 4 Ã— factorial(3)\n             = 5 Ã— 4 Ã— 3 Ã— factorial(2)\n             = 5 Ã— 4 Ã— 3 Ã— 2 Ã— factorial(1)\n             = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1\n             = 120\n\nKEY CONCEPTS:\n- Input validation\n- Loop/recursion\n- Base case (recursion)\n- Return value', answer: 'Iterative or recursive solution', explanation: 'Factorial: multiply all integers from 1 to n'},
    {question: 'Write code to check if a string is a palindrome', workingOut: 'PROBLEM: Check if string reads same forwards and backwards\nExample: "racecar" â†’ True, "hello" â†’ False\n\nSOLUTION 1: String reversal\n\ndef is_palindrome_v1(text):\n    """Check palindrome by reversing"""\n    # Remove spaces and convert to lowercase\n    text = text.replace(" ", "").lower()\n    \n    # Compare with reverse\n    return text == text[::-1]\n\n# Test\nprint(is_palindrome_v1("racecar"))  # True\nprint(is_palindrome_v1("A man a plan a canal Panama"))  # True\n\nSOLUTION 2: Two pointers\n\ndef is_palindrome_v2(text):\n    """Check palindrome using two pointers"""\n    text = text.replace(" ", "").lower()\n    \n    left = 0\n    right = len(text) - 1\n    \n    while left < right:\n        if text[left] != text[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\nSOLUTION 3: Recursive\n\ndef is_palindrome_v3(text):\n    """Check palindrome recursively"""\n    text = text.replace(" ", "").lower()\n    \n    # Base cases\n    if len(text) <= 1:\n        return True\n    \n    # Check first and last match\n    if text[0] != text[-1]:\n        return False\n    \n    # Recurse on middle\n    return is_palindrome_v3(text[1:-1])\n\nCOMPLEXITY:\n- Time: O(n) for all methods\n- Space: O(1) for v2, O(n) for v1 and v3\n\nKEY CONCEPTS:\n- String manipulation\n- Comparison operators\n- Recursion vs iteration\n- Algorithm efficiency', answer: 'Multiple approaches: reverse, two-pointer, recursive', explanation: 'Palindrome: same forwards and backwards'},
    {question: 'Implement a binary search algorithm', workingOut: 'PROBLEM: Search for value in SORTED list\nBinary search: O(log n) - much faster than linear O(n)\n\nALGORITHM:\n1. Find middle element\n2. If target = middle: found!\n3. If target < middle: search left half\n4. If target > middle: search right half\n5. Repeat until found or no elements left\n\nIMPLEMENTATION:\n\ndef binary_search(arr, target):\n    """Find target in sorted array"""\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        # Find middle (avoid overflow)\n        mid = left + (right - left) // 2\n        \n        # Check if target at middle\n        if arr[mid] == target:\n            return mid  # Found at index mid\n        \n        # Target in left half\n        elif target < arr[mid]:\n            right = mid - 1\n        \n        # Target in right half\n        else:\n            left = mid + 1\n    \n    return -1  # Not found\n\nEXAMPLE TRACE:\narr = [1, 3, 5, 7, 9, 11, 13, 15]\ntarget = 7\n\nIteration 1:\nleft=0, right=7, mid=3\narr[3]=7 â†’ FOUND at index 3!\n\nEXAMPLE 2:\ntarget = 6 (not in array)\n\nIteration 1: mid=3, arr[3]=7, target<7 â†’ right=2\nIteration 2: mid=1, arr[1]=3, target>3 â†’ left=2\nIteration 3: mid=2, arr[2]=5, target>5 â†’ left=3\nNow left > right â†’ return -1 (not found)\n\nRECURSIVE VERSION:\n\ndef binary_search_recursive(arr, target, left, right):\n    if left > right:\n        return -1  # Base case: not found\n    \n    mid = left + (right - left) // 2\n    \n    if arr[mid] == target:\n        return mid\n    elif target < arr[mid]:\n        return binary_search_recursive(arr, target, left, mid-1)\n    else:\n        return binary_search_recursive(arr, target, mid+1, right)\n\nREQUIREMENTS:\n- Array MUST be sorted\n- Returns index or -1\n- O(log n) time complexity\n- O(1) space (iterative)', answer: 'Divide and conquer: repeatedly halve search space', explanation: 'Binary search: O(log n) on sorted data'},
    {question: 'Explain different data types and when to use them', workingOut: 'DATA TYPES:\n\n1. INTEGER (int)\n- Whole numbers: -5, 0, 42, 1000\n- Use for: counting, indexing, IDs\n- Example: age = 25\n- Operations: +, -, *, //, %, **\n\n2. FLOAT (float)\n- Decimal numbers: 3.14, -0.5, 2.0\n- Use for: measurements, calculations\n- Example: price = 19.99\n- WARNING: Precision issues (0.1 + 0.2 â‰  0.3)\n\n3. STRING (str)\n- Text: "hello", \'Python\', """multi-line"""\n- Use for: names, messages, text\n- Example: name = "Alice"\n- Immutable in Python\n- Operations: +, *, slicing, methods\n\n4. BOOLEAN (bool)\n- True or False only\n- Use for: conditions, flags\n- Example: is_valid = True\n- Result of comparisons: 5 > 3 â†’ True\n\n5. LIST (array in some languages)\n- Ordered collection: [1, 2, 3]\n- Mutable (can change)\n- Mixed types allowed: [1, "two", 3.0]\n- Use for: collections, sequences\n\n6. TUPLE\n- Like list but IMMUTABLE: (1, 2, 3)\n- Use for: fixed data, dictionary keys\n- Faster than lists\n\n7. DICTIONARY (dict)\n- Key-value pairs: {"name": "Alice", "age": 25}\n- Fast lookup: O(1)\n- Use for: mappings, JSON-like data\n\n8. SET\n- Unordered unique elements: {1, 2, 3}\n- No duplicates\n- Use for: membership testing, removing duplicates\n\nTYPE CONVERSION:\nint("42")     â†’ 42\nfloat("3.14") â†’ 3.14\nstr(42)       â†’ "42"\nbool(0)       â†’ False (0 and empty = False)\nbool(1)       â†’ True\n\nTYPE CHECKING:\ntype(42)        â†’ <class \'int\'>\nisinstance(x, int) â†’ True/False\n\nCHOOSING DATA TYPE:\n- Need decimal? â†’ float\n- Just counting? â†’ int\n- Text? â†’ str\n- Yes/no? â†’ bool\n- Collection? â†’ list, tuple, set, dict\n- Need to change? â†’ list (mutable)\n- Fixed? â†’ tuple (immutable)', answer: 'Choose based on data nature and operations needed', explanation: 'Each data type optimized for specific use cases'}
  ], practiceQuestions: [{question: 'Which is a loop?', options: ['while', 'if', 'print', 'int'], answer: 'while', explanation: 'Iteration construct', difficulty: 'easy'}], tips: ['â­ Practice coding regularly', 'â­ Understand all structures'], commonMistakes: ['âŒ Syntax errors', 'âŒ Wrong loop type'], examStrategy: 'Programming: 40-50% of practical!'},

  {moduleNumber: 2, title: 'Data Structures', duration: '115 min', introduction: 'Arrays, lists, stacks, queues, trees, graphs', keyPoints: ['Arrays: fixed size', 'Lists: dynamic size', 'Stack: LIFO', 'Queue: FIFO', 'Trees: hierarchical', 'Graphs: nodes and edges'], explanation: 'Organizing data efficiently', examples: [{question: 'Stack operations?', workingOut: 'Push: add to top\nPop: remove from top\nPeek: view top\nLIFO: Last In First Out', answer: 'Push, pop, peek - LIFO structure', explanation: 'Like stack of plates'}], practiceQuestions: [{question: 'Queue is?', options: ['FIFO', 'LIFO', 'Random', 'Sorted'], answer: 'FIFO', explanation: 'First In First Out', difficulty: 'easy'}], tips: ['â­ Understand when to use each', 'â­ Practice implementations'], commonMistakes: ['âŒ Confusing stack and queue'], examStrategy: 'Data structures: 15-20 marks!'},

  {moduleNumber: 3, title: 'Algorithms', duration: '120 min', introduction: 'Searching, sorting, complexity, Big O notation', keyPoints: ['Linear search: O(n)', 'Binary search: O(log n)', 'Bubble sort, merge sort, quick sort', 'Time complexity', 'Space complexity', 'Algorithm efficiency'], explanation: 'Step-by-step problem solving', examples: [
    {question: 'Implement and trace Bubble Sort', workingOut: 'ALGORITHM:\nRepeatedly swap adjacent elements if in wrong order\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n\nTRACE: [5, 2, 8, 1, 9]\n\nPass 1:\n[5,2,8,1,9] â†’ [2,5,8,1,9] (swap 5,2)\n[2,5,8,1,9] â†’ [2,5,8,1,9] (no swap)\n[2,5,8,1,9] â†’ [2,5,1,8,9] (swap 8,1)\n[2,5,1,8,9] â†’ [2,5,1,8,9] (no swap)\nLargest (9) bubbled to end!\n\nPass 2:\n[2,5,1,8,9] â†’ [2,5,1,8,9]\n[2,5,1,8,9] â†’ [2,1,5,8,9] (swap 5,1)\n[2,1,5,8,9] â†’ [2,1,5,8,9]\n\nPass 3:\n[2,1,5,8,9] â†’ [1,2,5,8,9] (swap 2,1)\n[1,2,5,8,9] â†’ [1,2,5,8,9]\n\nPass 4: No swaps â†’ DONE\n\nFinal: [1,2,5,8,9]\n\nCOMPLEXITY:\nBest: O(n) - already sorted\nAverage: O(nÂ²)\nWorst: O(nÂ²) - reverse sorted\nSpace: O(1) - in place', answer: 'O(nÂ²) sorting - swap adjacent elements', explanation: 'Simple but slow for large data'},
    {question: 'Explain Big O notation with code examples', workingOut: 'BIG O: Growth rate of algorithm time/space\n\nO(1) - CONSTANT:\ndef get_first(arr):\n    return arr[0]  # Always 1 operation\n\nO(log n) - LOGARITHMIC:\ndef binary_search(arr, target):\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    # Halves search space each time\n\nO(n) - LINEAR:\ndef find_max(arr):\n    max_val = arr[0]\n    for num in arr:  # Checks every element\n        if num > max_val:\n            max_val = num\n    return max_val\n\nO(n log n) - LOG-LINEAR:\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])   # log n divisions\n    right = merge_sort(arr[mid:])\n    return merge(left, right)      # n merging\n\nO(nÂ²) - QUADRATIC:\ndef bubble_sort(arr):\n    for i in range(len(arr)):      # n times\n        for j in range(len(arr)):  # n times each\n            # n Ã— n = nÂ²\n\nO(2â¿) - EXPONENTIAL:\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)  # Doubles each level\n\nRULES:\n1. Drop constants: O(2n) â†’ O(n)\n2. Keep dominant: O(nÂ² + n) â†’ O(nÂ²)\n3. Usually worst case\n\nCOMPARISON (n=1000):\nO(1):      1 op\nO(log n):  ~10 ops\nO(n):      1,000 ops\nO(n log n): ~10,000 ops\nO(nÂ²):     1,000,000 ops\nO(2â¿):     10Â³â°â° ops (impossible!)', answer: 'Describes scalability: O(1) best to O(2â¿) worst', explanation: 'Measure algorithm efficiency'},
    {question: 'Implement Merge Sort with detailed steps', workingOut: 'DIVIDE AND CONQUER ALGORITHM\n\ndef merge_sort(arr):\n    # Base case\n    if len(arr) <= 1:\n        return arr\n    \n    # Divide\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # Conquer (merge)\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    # Compare and merge\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\nTRACE: [38, 27, 43, 3, 9, 82, 10]\n\nDIVIDE PHASE:\n[38, 27, 43, 3, 9, 82, 10]\n    â†“\n[38, 27, 43, 3]    [9, 82, 10]\n    â†“                  â†“\n[38, 27] [43, 3]   [9, 82] [10]\n    â†“       â†“          â†“      â†“\n[38] [27] [43] [3]  [9] [82]  [10]\n\nMERGE PHASE:\n[27, 38]  [3, 43]   [9, 82]  [10]\n    â†“         â†“          â†“\n[3, 27, 38, 43]    [9, 10, 82]\n         â†“              â†“\n[3, 9, 10, 27, 38, 43, 82]\n\nMERGE EXAMPLE: [27, 38] and [3, 43]\nCompare 27 vs 3 â†’ 3 smaller â†’ [3]\nCompare 27 vs 43 â†’ 27 smaller â†’ [3, 27]\nCompare 38 vs 43 â†’ 38 smaller â†’ [3, 27, 38]\nOnly 43 left â†’ [3, 27, 38, 43]\n\nCOMPLEXITY:\nTime: O(n log n) all cases\n- log n levels (divisions)\n- n work per level (merging)\nSpace: O(n) for temporary arrays\nStable: YES (maintains order)\n\nADVANTAGES:\n+ Consistent O(n log n)\n+ Stable sort\n+ Good for linked lists\n\nDISADVANTAGES:\n- Uses extra space\n- Slower than quicksort in practice', answer: 'O(n log n) - divide, sort, merge', explanation: 'Efficient divide-and-conquer sorting'},
    {question: 'Implement Stack and Queue data structures', workingOut: 'STACK (LIFO - Last In First Out):\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        return None\n    \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n    \n    def size(self):\n        return len(self.items)\n\nEXAMPLE:\nstack = Stack()\nstack.push(1)    # [1]\nstack.push(2)    # [1, 2]\nstack.push(3)    # [1, 2, 3]\nstack.pop()      # Returns 3, stack = [1, 2]\nstack.peek()     # Returns 2 (doesnt remove)\n\nUSE CASES:\n- Function call stack\n- Undo/Redo\n- Expression evaluation\n- Backtracking algorithms\n\nQUEUE (FIFO - First In First Out):\n\nfrom collections import deque\n\nclass Queue:\n    def __init__(self):\n        self.items = deque()\n    \n    def enqueue(self, item):\n        self.items.append(item)\n    \n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.popleft()\n        return None\n    \n    def front(self):\n        if not self.is_empty():\n            return self.items[0]\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n    \n    def size(self):\n        return len(self.items)\n\nEXAMPLE:\nqueue = Queue()\nqueue.enqueue(1)  # [1]\nqueue.enqueue(2)  # [1, 2]\nqueue.enqueue(3)  # [1, 2, 3]\nqueue.dequeue()   # Returns 1, queue = [2, 3]\nqueue.front()     # Returns 2 (doesnt remove)\n\nUSE CASES:\n- Task scheduling\n- BFS traversal\n- Print queue\n- Message buffers\n\nCOMPLEXITY:\nAll operations: O(1)\n\nKEY DIFFERENCE:\nStack: Remove most recent (LIFO)\nQueue: Remove oldest (FIFO)', answer: 'Stack: LIFO (push/pop). Queue: FIFO (enqueue/dequeue)', explanation: 'Fundamental linear data structures'}
  ], practiceQuestions: [{question: 'Fastest sorting algorithm?', options: ['Quick sort O(n log n)', 'Bubble sort O(nÂ²)', 'Linear O(n)', 'Constant O(1)'], answer: 'Quick sort O(n log n)', explanation: 'Average case', difficulty: 'medium'}], tips: ['â­ Learn Big O notation', 'â­ Trace algorithms'], commonMistakes: ['âŒ Wrong complexity analysis'], examStrategy: 'Algorithms: 20-25 marks!'},

  {moduleNumber: 4, title: 'Object-Oriented Programming', duration: '110 min', introduction: 'Classes, objects, inheritance, polymorphism, encapsulation', keyPoints: ['Classes: blueprints', 'Objects: instances', 'Encapsulation: data hiding', 'Inheritance: reuse code', 'Polymorphism: many forms'], explanation: 'Modern programming paradigm', examples: [{question: 'What is encapsulation?', workingOut: 'Bundling data and methods\nHiding internal details\nPublic interface\nPrivate implementation', answer: 'Data hiding and bundling in classes', explanation: 'Information hiding'}], practiceQuestions: [{question: 'Inheritance allows?', options: ['Code reuse', 'Data hiding', 'Sorting', 'Searching'], answer: 'Code reuse', explanation: 'Child inherits from parent', difficulty: 'easy'}], tips: ['â­ Practice class design', 'â­ Understand all principles'], commonMistakes: ['âŒ Not using encapsulation'], examStrategy: 'OOP: 15-20 marks!'},

  {moduleNumber: 5, title: 'Computer Systems', duration: '105 min', introduction: 'CPU, memory, storage, Von Neumann architecture', keyPoints: ['CPU: ALU, CU, registers', 'Fetch-decode-execute cycle', 'RAM vs ROM', 'Cache memory', 'Von Neumann architecture', 'Harvard architecture'], explanation: 'How computers work internally', examples: [{question: 'Describe fetch-decode-execute', workingOut: 'Fetch: get instruction from memory\nDecode: interpret instruction\nExecute: carry out instruction\nRepeat cycle', answer: 'CPU instruction cycle', explanation: 'Fundamental operation'}], practiceQuestions: [{question: 'Cache is?', options: ['Fast memory near CPU', 'Slow storage', 'Input device', 'Output device'], answer: 'Fast memory near CPU', explanation: 'Improves speed', difficulty: 'easy'}], tips: ['â­ Understand CPU components', 'â­ Know memory hierarchy'], commonMistakes: ['âŒ Confusing RAM and ROM'], examStrategy: 'Systems: 15-20 marks!'},

  {moduleNumber: 6, title: 'Networks', duration: '110 min', introduction: 'Protocols, TCP/IP, LAN/WAN, client-server, peer-to-peer', keyPoints: ['LAN vs WAN', 'TCP/IP model', 'HTTP, HTTPS, FTP', 'Client-server architecture', 'Peer-to-peer', 'Network topologies'], explanation: 'How computers communicate', examples: [{question: 'What is a protocol?', workingOut: 'Set of rules\nFor data transmission\nEnsures compatibility\nExample: TCP/IP', answer: 'Rules for communication between devices', explanation: 'Standard format'}], practiceQuestions: [{question: 'HTTPS provides?', options: ['Secure HTTP', 'Fast HTTP', 'Local HTTP', 'Simple HTTP'], answer: 'Secure HTTP', explanation: 'Encrypted communication', difficulty: 'easy'}], tips: ['â­ Learn all protocols', 'â­ Understand topologies'], commonMistakes: ['âŒ Confusing protocols'], examStrategy: 'Networks: 12-18 marks!'},

  {moduleNumber: 7, title: 'Databases', duration: '105 min', introduction: 'SQL, normalization, relationships, transactions', keyPoints: ['Relational databases', 'SQL: SELECT, INSERT, UPDATE, DELETE', 'Primary and foreign keys', 'Normalization: 1NF, 2NF, 3NF', 'Relationships: one-to-many, many-to-many'], explanation: 'Organizing and querying data', examples: [{question: 'Write SQL to select all students', workingOut: 'SELECT * FROM Students;\nSELECT = choose columns\n* = all columns\nFROM = specify table', answer: 'SELECT * FROM Students;', explanation: 'Basic SELECT query'}], practiceQuestions: [{question: 'Primary key is?', options: ['Unique identifier', 'Foreign reference', 'Index', 'Query'], answer: 'Unique identifier', explanation: 'Uniquely identifies record', difficulty: 'easy'}], tips: ['â­ Practice SQL queries', 'â­ Understand normalization'], commonMistakes: ['âŒ SQL syntax errors'], examStrategy: 'Databases: 12-18 marks!'},

  {moduleNumber: 8, title: 'Security & Encryption', duration: '100 min', introduction: 'Threats, authentication, encryption, hashing', keyPoints: ['Types of threats: malware, phishing, DDoS', 'Authentication methods', 'Symmetric encryption', 'Asymmetric encryption', 'Hashing', 'Digital signatures'], explanation: 'Protecting data and systems', examples: [{question: 'Symmetric vs asymmetric encryption?', workingOut: 'Symmetric: same key encrypt/decrypt, fast\nAsymmetric: public/private keys, slow\nAsymmetric more secure', answer: 'Symmetric uses one key, asymmetric uses two', explanation: 'Different approaches'}], practiceQuestions: [{question: 'Hashing is?', options: ['One-way function', 'Two-way encryption', 'Authentication', 'Virus'], answer: 'One-way function', explanation: 'Cannot reverse', difficulty: 'medium'}], tips: ['â­ Understand encryption types', 'â­ Know security threats'], commonMistakes: ['âŒ Confusing hashing and encryption'], examStrategy: 'Security: 10-15 marks!'},

  {moduleNumber: 9, title: 'Boolean Logic & Circuits', duration: '105 min', introduction: 'Logic gates, truth tables, Boolean algebra, circuit design', keyPoints: ['AND, OR, NOT gates', 'NAND, NOR, XOR gates', 'Truth tables', 'Boolean algebra rules', 'De Morgan\'s laws', 'Circuit simplification'], explanation: 'Foundation of digital electronics', examples: [{question: 'AND gate truth table?', workingOut: '0 AND 0 = 0\n0 AND 1 = 0\n1 AND 0 = 0\n1 AND 1 = 1\nOnly 1 when both 1', answer: 'Output 1 only when both inputs 1', explanation: 'Logical AND'}], practiceQuestions: [{question: 'NOT gate does?', options: ['Inverts input', 'AND operation', 'OR operation', 'Nothing'], answer: 'Inverts input', explanation: '0â†’1, 1â†’0', difficulty: 'easy'}], tips: ['â­ Draw truth tables', 'â­ Learn Boolean laws'], commonMistakes: ['âŒ Wrong truth table entries'], examStrategy: 'Boolean: 10-15 marks!'},

  {moduleNumber: 10, title: 'Data Representation', duration: '100 min', introduction: 'Binary, hex, characters, images, sound', keyPoints: ['Binary number system', 'Hexadecimal', 'Two\'s complement', 'ASCII and Unicode', 'Bitmap vs vector', 'Sound sampling'], explanation: 'How computers store different data types', examples: [{question: 'Convert 25 to binary', workingOut: '25 Ã· 2 = 12 R 1\n12 Ã· 2 = 6 R 0\n6 Ã· 2 = 3 R 0\n3 Ã· 2 = 1 R 1\n1 Ã· 2 = 0 R 1\nRead up: 11001', answer: '11001', explanation: 'Repeated division by 2'}], practiceQuestions: [{question: 'Hexadecimal base?', options: ['16', '10', '8', '2'], answer: '16', explanation: '0-9, A-F', difficulty: 'easy'}], tips: ['â­ Practice conversions', 'â­ Understand two\'s complement'], commonMistakes: ['âŒ Wrong binary conversion'], examStrategy: 'Data representation: 10-15 marks!'},

  {moduleNumber: 11, title: 'Software Development', duration: '110 min', introduction: 'SDLC, Agile, testing, version control', keyPoints: ['Waterfall model', 'Agile methodology', 'Testing: unit, integration, system', 'Debugging techniques', 'Version control: Git', 'Documentation'], explanation: 'Professional software development practices', examples: [{question: 'Agile vs Waterfall?', workingOut: 'Waterfall: linear, sequential\nAgile: iterative, flexible\nAgile adapts to change\nWaterfall structured', answer: 'Waterfall linear, Agile iterative', explanation: 'Different approaches'}], practiceQuestions: [{question: 'Unit testing tests?', options: ['Individual functions', 'Whole system', 'User interface', 'Network'], answer: 'Individual functions', explanation: 'Small components', difficulty: 'easy'}], tips: ['â­ Understand all methodologies', 'â­ Know testing types'], commonMistakes: ['âŒ Not testing thoroughly'], examStrategy: 'Software dev: 10-15 marks!'},

  {moduleNumber: 12, title: 'Computational Thinking', duration: '100 min', introduction: 'Abstraction, decomposition, pattern recognition, algorithms', keyPoints: ['Abstraction: remove unnecessary details', 'Decomposition: break into parts', 'Pattern recognition', 'Algorithmic thinking', 'Problem-solving strategies'], explanation: 'Thinking like a computer scientist', examples: [{question: 'What is abstraction?', workingOut: 'Hiding complexity\nShow only relevant details\nIgnore unnecessary info\nSimplify problem', answer: 'Removing unnecessary detail to focus on essentials', explanation: 'Simplification'}], practiceQuestions: [{question: 'Decomposition means?', options: ['Breaking into smaller parts', 'Combining parts', 'Abstracting', 'Repeating'], answer: 'Breaking into smaller parts', explanation: 'Divide and conquer', difficulty: 'easy'}], tips: ['â­ Apply to all problems', 'â­ Practice problem-solving'], commonMistakes: ['âŒ Not using computational thinking'], examStrategy: 'Computational thinking: throughout paper!'},

  {moduleNumber: 13, title: 'Ethics & Society', duration: '95 min', introduction: 'Privacy, copyright, AI ethics, environmental impact', keyPoints: ['Data Protection Act', 'GDPR', 'Copyright and licensing', 'AI ethics', 'Environmental impact', 'Digital divide', 'Censorship'], explanation: 'Social and ethical implications', examples: [{question: 'What is GDPR?', workingOut: 'General Data Protection Regulation\nProtects personal data\nGives rights to individuals\nPenalties for breaches', answer: 'EU data protection law', explanation: 'Privacy regulation'}], practiceQuestions: [{question: 'Digital divide refers to?', options: ['Unequal access to technology', 'Binary code', 'Data storage', 'Network speed'], answer: 'Unequal access to technology', explanation: 'Inequality', difficulty: 'medium'}], tips: ['â­ Understand all legislation', 'â­ Discuss implications'], commonMistakes: ['âŒ Not considering ethical issues'], examStrategy: 'Ethics: 8-12 marks!'},

  {moduleNumber: 14, title: 'Theory of Computation', duration: '105 min', introduction: 'Turing machines, computability, complexity classes', keyPoints: ['Turing machine model', 'Church-Turing thesis', 'Halting problem', 'P vs NP', 'Tractable vs intractable', 'Heuristic approaches'], explanation: 'Theoretical foundations of computing', examples: [{question: 'What is the halting problem?', workingOut: 'Cannot determine if program will halt\nFor all possible inputs\nUndecidable problem\nProven by Turing', answer: 'Determining if a program terminates is undecidable', explanation: 'Fundamental limit'}], practiceQuestions: [{question: 'P problems are?', options: ['Polynomial time solvable', 'Impossible', 'Exponential', 'Linear'], answer: 'Polynomial time solvable', explanation: 'Efficiently solvable', difficulty: 'hard'}], tips: ['â­ Understand computability', 'â­ Know complexity classes'], commonMistakes: ['âŒ Confusing P and NP'], examStrategy: 'Theory: 8-12 marks!'},

  {moduleNumber: 15, title: 'Exam Mastery & A-Star Technique', duration: '120 min', introduction: 'NEA project, written exams, programming questions, theory', keyPoints: ['NEA: 20% of grade', 'Written paper strategy', 'Algorithm questions', 'Code tracing', 'Extended responses', 'Time management'], explanation: 'Computer Science exam skills', examples: [{question: 'Good NEA project?', workingOut: 'Real problem\nComplex solution\nFull documentation\nTesting evidence\nEvaluation', answer: 'Well-documented complex project', explanation: 'Quality over quantity'}], practiceQuestions: [{question: 'A-Star boundary?', options: ['80%+', '75%+', '90%+', '70%+'], answer: '80%+', explanation: 'Typically 80-85%', difficulty: 'easy'}], tips: ['â­ Start NEA early', 'â­ Practice coding by hand', 'â­ Learn theory thoroughly', 'â­ Trace algorithms', 'â­ Write clear explanations'], commonMistakes: ['âŒ Weak NEA documentation', 'âŒ Not practicing coding', 'âŒ Poor time management'], examStrategy: 'A-Star requires excellent NEA project, strong theory knowledge, and practical coding skills! Practice programming daily, document thoroughly! ðŸŽ¯'}
];

export default aLevelComputerScienceContent;

